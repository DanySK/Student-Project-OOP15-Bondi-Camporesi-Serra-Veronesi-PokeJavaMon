package model.map;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;

import com.badlogic.gdx.maps.MapLayer;
import com.badlogic.gdx.maps.MapObject;
import com.badlogic.gdx.maps.MapProperties;
import com.badlogic.gdx.maps.objects.RectangleMapObject;
import com.badlogic.gdx.maps.tiled.TiledMap;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;

import model.map.Drawable.Direction;
import model.map.tile.BadgeTeleport;
import model.map.tile.SpecialEncounterTile;
import model.map.tile.Sign;
import model.map.tile.Teleport;
import model.map.tile.Tile;
import model.map.tile.Tile.TileType;
import model.player.Player;
import model.player.PlayerImpl;
import model.pokemon.Pokedex;
import model.trainer.GymLeader;
import model.trainer.StaticTrainerFactory;
import model.trainer.Trainer;

/**
 * Implementation of {@link PokeMap} utilizing libgdx {@link TiledMap} which extract informations
 * from the map.tmx generated by the editor "Tiled". It stores inside a matrix of all {@link TileTypes} of each {@link Tile}
 * Also stores {@link Set}s of special objects that cannot be represented only with a {@link TileType} such as {@link Sign}s, {@link Teleport}.. etc
 */
public class PokeMapImpl implements PokeMap {

	//Names of layers in map.tmx
	private static final String BACKGROUND = "background";
	private static final String FOREGROUND = "foreground";
	private static final String DOORS = "doorLayer";
	private static final String SIGNS = "signLayer";
	private static final String ENCOUNTERS = "pokemonEncounterLayer";
	private static final String ZONES = "zoneLayer";
	
	//base map without complex objects
	private Tile.TileType[][] map;
	
	//Sets of objects present in the map
	private Set<Position> collisions;
	private Set<Teleport> teleports;
	private Set<Sign> signs;
	private Set<Trainer> trainers;
	private Set<PokemonEncounterZone> pokemonEncounterZones;
	private Set<WalkableZone> walkableZones;
	private Set<NPC> npcs;
	private Set<GymLeader> gymLeaders;
	private Set<SpecialEncounterTile> tileEncounters;
	private Set<SpecialEncounterTile> tileEncountersRemoved;
	private PokeMarket market;
	private Position pokeCenterSpawn;
	
	//TiledMap set to protected in case of class that will extend this map
	protected final TiledMap tiledMap;
	
	//measures about the map
	private int mapHeight;
	private int mapWidth;
	private int tileHeight;
	private int tileWidth;
	
	/**
	 * Creates a new object extracting necessary data from a {@link TiledMap}
	 * @param map
	 * 			{@link TiledMap} created with map.tmx
	 */
	public PokeMapImpl(final TiledMap map) {
		this.tiledMap = map;
		new MapImporter(this.tiledMap).importMap();
	}

	/**
	 * Inner class used to import necessary data from {@link TiledMap}
	 */
	public class MapImporter {

		private final TiledMap tm;
		
		public MapImporter(final TiledMap tm) {
			this.tm = tm;
		}
		
		/**
		 * Only public method of this class, 
		 * @param tm
		 * 		{@link TiledMap} created with map.tmx
		 */
		public void importMap() {
			final TiledMapTileLayer background = ((TiledMapTileLayer) tm.getLayers().get(BACKGROUND));
			final TiledMapTileLayer foreground = ((TiledMapTileLayer) tm.getLayers().get(FOREGROUND));
			final MapLayer doorLayer = ((MapLayer) tm.getLayers().get(DOORS));
			final MapLayer signLayer = ((MapLayer) tm.getLayers().get(SIGNS));
			final MapLayer encounterLayer = ((MapLayer) tm.getLayers().get(ENCOUNTERS));
			final MapLayer zoneLayer = ((MapLayer) tm.getLayers().get(ZONES));
			
			mapHeight = (int) background.getHeight();
			mapWidth = (int) background.getWidth();
			tileHeight = (int) background.getTileHeight();
			tileWidth = (int) background.getTileWidth();
			initMap();
			
			collisions = new HashSet<>();
			signs = new HashSet<>();
			teleports = new HashSet<>();
			trainers = new HashSet<>();
			gymLeaders = new HashSet<>();
	        tileEncounters = new HashSet<>();
	        tileEncountersRemoved = new HashSet<>();
			npcs = new HashSet<>();
			pokemonEncounterZones = new HashSet<>();
			walkableZones = new HashSet<>();
					
			importTeleports(doorLayer);
			importSigns(signLayer);
			
			importPokemonEncounterZones(encounterLayer);
			importWalkableZones(zoneLayer);
			setBackgroundAndForeground(background, foreground, encounterLayer);
		}
		
		private void initMap() {
			map = new Tile.TileType[mapWidth][mapHeight];
			for (int i = 0; i < mapWidth ; i++) {
				for (int j = 0; j < mapHeight; j++) {
					map[i][j] = Tile.TileType.TERRAIN;
				}
			}
		}
		private void setBackgroundAndForeground(final TiledMapTileLayer background, final TiledMapTileLayer foreground, final MapLayer encounterLayer) {
			for (int i = 0; i < mapWidth; i += 1) {
				for (int j = 0; j < mapHeight; j += 1) {
					
					final Cell backCell = background.getCell(getCorrectedCoordinateX(i), getCorrectedCoordinateY(j));
					final Cell frontCell = foreground.getCell(getCorrectedCoordinateX(i), getCorrectedCoordinateY(j));
					
					if (backCell != null) {
						addCell(backCell, i, j, encounterLayer);
					}
					if (frontCell != null) {
						addCell(frontCell, i, j, encounterLayer);
					}
					
				}
			}
		}
		
		private void addCell(final Cell c, final int tileX, final int tileY, final MapLayer encounterLayer) {
			if (c != null) {
				final MapProperties mp = c.getTile().getProperties();
				final String cellProperty = (mp.get("tileType", String.class)).toUpperCase();
				final Position p = new Position(tileX, tileY);
				final boolean isWalkable = Boolean.valueOf((mp.get("walkable", String.class)));
				
				if (cellProperty.equals(TileType.WALL.toString())) {
					collisions.add(p);
					map[tileX][tileY] = TileType.WALL;
				
				} else if (cellProperty.equals(TileType.WATER.toString())) {
					/*Until we implement water*/
					collisions.add(p);
					map[tileX][tileY] = TileType.WATER;
					
				} else if (cellProperty.equals(TileType.TREE.toString())) {
					collisions.add(p);
					map[tileX][tileY] = TileType.TREE;
					
				} else if (cellProperty.equals(TileType.POKEMON_ENCOUNTER.toString())) {
					map[tileX][tileY] = TileType.POKEMON_ENCOUNTER;
					
				} else if (cellProperty.equals(TileType.SIGN.toString())) {
					collisions.add(p);
					map[tileX][tileY] = TileType.SIGN;
					
				} else if (cellProperty.equals(TileType.NPC.toString())) {
					map[tileX][tileY] = TileType.NPC;
					Direction d = Direction.NORTH;
					if (mp.get("FRONT_ID").equals("-1")) {
						d = Direction.SOUTH;
					} else if(mp.get("LEFT_ID").equals("-1")) {
						d = Direction.WEST;
					} else if (mp.get("RIGHT_ID").equals("-1")) {
						d = Direction.EAST;
					}
					final AbstractCharacter ac = importNPC(tileX, tileY, d);
					if (ac != null) {
						if (ac instanceof Trainer) {
							trainers.add((Trainer)ac);
						} else if (ac instanceof NPC) {
							npcs.add((NPC) ac);
						} else if (ac instanceof GymLeader) {
							gymLeaders.add((GymLeader) ac);
						}
					}
					collisions.add(p);

				} else if (cellProperty.equals(TileType.TELEPORT.toString()) || cellProperty.equals(TileType.BADGETELEPORT.toString())) {
					map[tileX][tileY] = TileType.TELEPORT;
				
				} else if (cellProperty.equals(TileType.MARKET.toString())) {
					map[tileX][tileY] = TileType.MARKET;
					market = new PokeMarket(tileX, tileY);
					collisions.add(p);
					
				} else if (cellProperty.equals(TileType.CENTER.toString())) {
					map[tileX][tileY] = TileType.CENTER;
					collisions.add(p);
				
				} else if (cellProperty.equals(TileType.START.toString())) {
					PlayerImpl.START_X = tileX;
					PlayerImpl.START_Y = tileY;
					map[tileX][tileY] = TileType.START;
					PlayerImpl.getPlayer().setStartingPoint(tileX, tileY);
				
				} else if (cellProperty.equals(TileType.DEFEAT.toString())) {
					pokeCenterSpawn = new Position(tileX, tileY);
					map[tileX][tileY] = TileType.DEFEAT;
				
				} else if (cellProperty.equals(TileType.ENCOUNTER.toString())) {
					tileEncounters.add(new SpecialEncounterTile(Pokedex.valueOf(mp.get("pokemon", String.class)), 
							Integer.parseInt(mp.get("lvl", String.class)), tileX, tileY, Direction.SOUTH, mp.get("cry", String.class)));
					map[tileX][tileY] = TileType.ENCOUNTER;
					collisions.add(new Position(tileX, tileY));
				} else if (!isWalkable) {
					map[tileX][tileY] = TileType.WALL;
					collisions.add(p);
				}
			}
		}
		
		private AbstractCharacter importNPC(final int tileX, final int tileY, final Direction d) {
			final MapLayer trainerLayer = tm.getLayers().get("trainerLayer");
			AbstractCharacter retCharacter = null;
			for (final MapObject mobj : trainerLayer.getObjects()) {
				final int trainerInMapX = getCorrectedCoordinateX(mobj.getProperties().get("x", Float.class).intValue() / tileWidth);
				final int trainerInMapY = getCorrectedCoordinateY(mobj.getProperties().get("y", Float.class).intValue() / tileHeight);

				if (trainerInMapX == tileX && trainerInMapY == tileY ) {
					final String npcType = mobj.getProperties().get("type", String.class);
					if (npcType != null) {
						if ((npcType.equals(Trainer.TYPE_TRAINER_NAME) || npcType.equals(GymLeader.TYPE_GYM_LEADER))) {
							final ArrayList<String>	pkmns_lvl = new ArrayList<>();
						
							for (int i = 1; i <= 6; i++) {
								if (mobj.getProperties().containsKey(i + "_POKEMON=LVL") && !mobj.getProperties().get(i + "_POKEMON=LVL", String.class).isEmpty()) {
									pkmns_lvl.add(mobj.getProperties().get(i + "_POKEMON=LVL", String.class));
								}
							}
							MapProperties mp = mobj.getProperties();
							final String trainerName = mp.get("name",String.class);
							final String initMessage = mp.get("initMessage", String.class);
							final String winMessage = mp.get("winMessage", String.class);
							final String lostMessage = mp.get("lostMessage", String.class);
							final int money = Integer.parseInt(mp.get("money", String.class));
							final int trainerID = Integer.parseInt(mp.get("trainerID", String.class));
							if (npcType.equals(Trainer.TYPE_TRAINER_NAME)) {
								retCharacter = StaticTrainerFactory.createTrainer(trainerName, d, false, tileX, tileY, pkmns_lvl, 
										initMessage, lostMessage, winMessage, money, trainerID);
							} else {
								final int badge = Integer.parseInt(mp.get("badgeID", String.class));
								retCharacter = StaticTrainerFactory.createGymLeader(trainerName, d, false, tileX, tileY, pkmns_lvl, 
										initMessage, lostMessage, winMessage, money,trainerID, badge);
							}
						} else if (npcType.equals(TileType.NPC.toString())) {
							retCharacter = new NPC(mobj.getProperties().get("name", String.class), tileX, tileY, d, mobj.getProperties().get("message", String.class));
						} 
					}
				}
			}
			if (retCharacter == null) {
				System.out.println("if charNULL postion: " + new Position(tileX, tileY));
			}
			return retCharacter;
		}
		
		private void importTeleports(final MapLayer doorLayer) {
			if (doorLayer.getObjects() == null) {
				throw new IllegalArgumentException("Layer does not contain objects");
			} 
			for (final MapObject mobj : doorLayer.getObjects()) {
				if (mobj.getProperties().containsKey("DOOR_X")) {
					final int real_x = getCorrectedCoordinateX(mobj.getProperties().get("x", Float.class).intValue() / tileWidth);
					final int real_y = getCorrectedCoordinateY(mobj.getProperties().get("y", Float.class).intValue() / tileHeight);
					final int to_x = Integer.parseInt((String)mobj.getProperties().get("DOOR_X"));
					final int to_y = Integer.parseInt((String)mobj.getProperties().get("DOOR_Y"));
					Teleport tmp;
					if (mobj.getProperties().containsKey("badgesRequired")) {
						tmp = new BadgeTeleport(real_x, real_y, to_x, to_y, Integer.parseInt(mobj.getProperties().get("badgesRequired", String.class)));
					} else {
						tmp = new Teleport(real_x, real_y, to_x, to_y);
					}		
					teleports.add(tmp);
				}
			}
		}
		
		private void importSigns(final MapLayer signLayer) {
			if (signLayer.getObjects() == null) {
				throw new IllegalArgumentException("Layer does not contain objects");
			} 
			for (final MapObject mobj : signLayer.getObjects()) {
				if (mobj.getProperties().containsKey("signMessage")) {
					final int real_x = getCorrectedCoordinateX(getCorrectedCoordinateX(mobj.getProperties().get("x", Float.class).intValue() / tileWidth));
					final int real_y = getCorrectedCoordinateY(mobj.getProperties().get("y", Float.class).intValue() / tileHeight);
					final Sign tmp = new Sign(real_x, real_y, (String) mobj.getProperties().get("signMessage"));
					signs.add(tmp);
				}
			}
		}
	
		private void importWalkableZones(final MapLayer zoneLayer) {
			for (final MapObject z : zoneLayer.getObjects()) {
				RectangleMapObject rect = (RectangleMapObject) z;
				final int width = (int) (rect.getRectangle().width / tileWidth);
				final int height = (int) (rect.getRectangle().height / tileHeight) - 1;
				final int real_x = getCorrectedCoordinateX((int) (rect.getRectangle().x / tileWidth));
				final int real_y = getCorrectedCoordinateY((int) (rect.getRectangle().y / tileHeight)) - height;
				final String musicPath = (String) z.getProperties().get("music");
				final String name = (String) z.getProperties().get("zoneType");
				walkableZones.add(new WalkableZone(name, real_x, real_y, width, height, "/" + musicPath));
				
			}
		}
		
		private void importPokemonEncounterZones(final MapLayer encounterLayer) {
			for (final MapObject z : encounterLayer.getObjects()) {
				RectangleMapObject rect = (RectangleMapObject) z;
				final int real_x = getCorrectedCoordinateX((int) (rect.getRectangle().x / tileWidth));
				final int width = (int) (rect.getRectangle().width / tileWidth);
				final int height = (int) (rect.getRectangle().height / tileHeight) - 1;
				final int real_y = getCorrectedCoordinateY((int) (rect.getRectangle().y / tileHeight)) - height;
				final int id = Integer.parseInt(rect.getProperties().get("zoneID", String.class));
				final int avgLvl = Integer.parseInt(rect.getProperties().get("avgLvl", String.class));
				final String pkmnList = rect.getProperties().get("pokemonList", String.class);
				final Set<Pokedex> pkmnSet = new HashSet<>();
				for (final String pkmn : pkmnList.split(" ")) {
					for (final Pokedex pkmnID : Pokedex.values()) {
						if (pkmn.equals(pkmnID.toString())) {
							pkmnSet.add(pkmnID);
						}
					}
				}
				pokemonEncounterZones.add(new PokemonEncounterZone(id, pkmnSet, avgLvl, real_x, real_y, width, height));
			}
		}
	}

	@Override
	public boolean isOutOfBounds(final int x, final int y) {
		return x > this.mapWidth ||  x < 0 || y > this.mapHeight || y < 0;
	}
	
	@Override
	public int getMapHeight() {
		return this.mapHeight;
	}

	@Override
	public int getMapWidth() {
		return this.mapWidth;
	}
	
	@Override
	public int getTileWidth() {
		return this.tileWidth;
	}

	@Override
	public int getTileHeight() {
		return this.tileHeight;
	}

	
	@Override
	public Set<Position> getCollisions() {
		return Collections.unmodifiableSet(this.collisions);
	}

	@Override
	public void removeCollision(Position p) {
		if (this.collisions.contains(p)) {
			this.collisions.remove(p);
			return;
		}
		this.map[p.getX()][p.getY()] = TileType.TERRAIN;
		throw new IllegalArgumentException();
	}

	@Override
	public void addCollision(Position p) {
		this.collisions.add(p);
	}

	@Override
	public boolean isWalkable(final int x, final int y) {
		if (this.isOutOfBounds(x, y)) {
			return false;
		}
		
		boolean isCollision = false;
		for (final Position p : this.collisions) {
			if (p.getX() == x && p.getY() == y) {
				isCollision = true;
			}
		}
		return this.map[x][y].isWalkable() && !isCollision;
	}
	
	@Override
	public boolean isWalkableNextToPlayer(final Direction d) {
		int nextX = PlayerImpl.getPlayer().getTileX();
		int nextY = PlayerImpl.getPlayer().getTileY();
		switch (d) {
		case NORTH :
			nextY -= 1;
			break;
		case SOUTH :
			nextY += 1;
			break;
		case EAST :
			nextX += 1;
			break;
		case WEST :
			nextX -= 1;
			break;
		default :
			break;
		}
		return this.isWalkable(nextX, nextY);
		
	}
	@Override
	public TileType getTileNextToPlayer(final Direction d) {
		Player p = PlayerImpl.getPlayer();
		final int tmpX = p.getTileX() + ((d == Direction.EAST || d == Direction.WEST) ? ((d == Direction.EAST) ? +1 : -1) : 0) ; 
		final int tmpY = p.getTileY() + ((d == Direction.SOUTH || d == Direction.NORTH) ? ((d == Direction.SOUTH) ? +1 : -1) : 0) ;

		return (this.isOutOfBounds(tmpX, tmpY)) ? TileType.WALL : this.map[tmpX][tmpY];
	}


	@Override
	public Set<Teleport> getTeleports() {
		return Collections.unmodifiableSet(this.teleports);
	}

	@Override
	public Optional<Teleport> getTeleport(int fromX, int fromY) {
		if (!this.isOutOfBounds(fromX, fromY) && this.map[fromX][fromY] == TileType.TELEPORT) {
			for (final Teleport t : teleports) {
				if (t.getFromX() == fromX && t.getFromY() == fromY) {
					return Optional.of(t);
				}
			}
		}
		return Optional.empty();
	}

	
	@Override
	public Set<Sign> getSigns() {
		return new HashSet<Sign>(this.signs);
	}

	@Override
	public Optional<Sign> getSign(int x, int y) {
		if (!this.isOutOfBounds(x, y) && this.map[x][y] == TileType.SIGN) {
			for (final Sign s : this.signs) {
				if (s.getTileX() == x & s.getTileY() == y) {
					return Optional.of(s);
				}
			}
		}
		return Optional.empty();
	}

	@Override
	public Tile.TileType getTileType(int x, int y) {
		return this.isOutOfBounds(x, y) ? TileType.WALL : this.map[x][y];
	}


	@Override
	public Set<WalkableZone> getWalkableZones() {
		return Collections.unmodifiableSet(this.walkableZones);
	}

	@Override
	public Optional<WalkableZone> getWalkableZone(int x, int y) {
		for (final WalkableZone wz : this.walkableZones) {
			if (wz.contains(x, y)) {
				return Optional.of(wz);
			}
		}
		
		return Optional.empty();
	}
	
	@Override
	public Set<Trainer> getTrainers() {
		return Collections.unmodifiableSet(this.trainers);
	}
	@Override
	public Optional<Trainer> getTrainer(int x, int y) {
		if (!this.isOutOfBounds(x, y) && this.map[x][y] == TileType.NPC) {
			for (final Trainer t : this.trainers) {
				if (t.getTileX() == x && t.getTileY() == y) {
					return Optional.of(t);
				}
			}
		}
		return Optional.empty();
	}
	
	@Override
	public void initTrainers(final Map<Integer, Boolean> trainerID_isDefeated) {
		for (final Entry<Integer, Boolean> e : trainerID_isDefeated.entrySet()) {
			if (!e.getValue()) {
				continue;
			}
			for (final Trainer t : this.trainers) {
				if (e.getKey() == t.getID()) {
					t.defeat();
				}
			}
		}
	}
    
	@Override
	public void turnCharacter(final Character c, final Direction d) {
	    final TiledMapTileLayer bg = (TiledMapTileLayer) this.tiledMap.getLayers().get(FOREGROUND);
	    final Cell tr = bg.getCell(this.getCorrectedCoordinateX(c.getTileX()), this.getCorrectedCoordinateY(c.getTileY()));
	    int val = -1;
	    switch (d) {
	    case WEST:
	        val = Integer.parseInt(tr.getTile().getProperties().get("LEFT_ID", String.class));
	        val++;
	        if (val > 0) {
	        	tr.setTile(this.tiledMap.getTileSets().getTile(val));
	        }
	        break;
	    case NORTH:
	        val = Integer.parseInt(tr.getTile().getProperties().get("REAR_ID", String.class));
            val++;
	        if (val > 0) {
            	tr.setTile(this.tiledMap.getTileSets().getTile(val));
            }
            break;
	    case EAST:
	        val = Integer.parseInt(tr.getTile().getProperties().get("RIGHT_ID", String.class));
            val++;
	        if (val > 0) {
            	tr.setTile(this.tiledMap.getTileSets().getTile(val));
            }
            break;
	    case SOUTH:
            val = Integer.parseInt(tr.getTile().getProperties().get("FRONT_ID", String.class));
            val++;
            if(val > 0) {
            	tr.setTile(this.tiledMap.getTileSets().getTile(val));
            }
            break;
        default :
        	return;
	    }
	}
    
	@Override
	public Set<GymLeader> getGymLeaders() {
		return Collections.unmodifiableSet(this.gymLeaders);
	}

	@Override
	public Optional<GymLeader> getGymLeader(int x, int y) {
		if (!this.isOutOfBounds(x, y) && this.map[x][y] == TileType.NPC) {
			for (final GymLeader gl : this.gymLeaders) {
				if (gl.getTileX() == x && gl.getTileY() == y) {
					return Optional.of(gl);
				}
			}
		}
		return Optional.empty();
	}

	@Override
	public void initGymLeaders(final int badges) {
		for (final GymLeader gl : this.gymLeaders) {
			if (gl.getBadge() <= badges) {
				gl.defeat();
			}
		}
	}

	@Override
	public Set<NPC> getNPCs() {
		return Collections.unmodifiableSet(this.npcs);
	}

	@Override
	public Optional<NPC> getNPC(int x, int y) {
		if (!this.isOutOfBounds(x, y) && this.map[x][y] == TileType.NPC) {
			for (final NPC npcs : this.npcs) {
				if (npcs.getTileX() == x && npcs.getTileY() == y) {
					return Optional.of(npcs);
				}
			}
		}
		return Optional.empty();
	}

	@Override
    public Set<SpecialEncounterTile> getEncounterTiles() {
		return Collections.unmodifiableSet(this.tileEncounters);
    }
    
    @Override
    public Optional<SpecialEncounterTile> getEncounterTile(final int x, final int y) {
		if (!this.isOutOfBounds(x, y) && this.map[x][y] == TileType.ENCOUNTER) {
			for (final SpecialEncounterTile et : this.tileEncounters) {
				if (et.getTileX() == x && et.getTileY() == y) {
					return Optional.of(et);
				}
			}
		}
		return Optional.empty();
    }
    
    @Override
    public void initDeletedEncounterTiles(final Set<String> pkmnsToBeDeleted) {
        final Set<Position> positionsToBeRemoved = new HashSet<>();
    	for (final String p : pkmnsToBeDeleted) {
    	    for (final SpecialEncounterTile et : this.tileEncounters) {
    		if (et != null && p != null) {
	    		if (et.getPokemon().getPokedexEntry().name().equals(p.toUpperCase())) {
	    			positionsToBeRemoved.add(new Position(et.tileX, et.tileY));
	    		}
    		}
    	    }
    	}
    	for (final Position p : positionsToBeRemoved) {
    	    this.deleteEncounterTile(p.getX(), p.getY());
    	}
    }
    
    @Override
    public Set<SpecialEncounterTile> getRemovedEncounterTiles() {
        return Collections.unmodifiableSet(this.tileEncountersRemoved);
    }
	
    @Override
    public void deleteEncounterTile(final int x, final int y) {
    	for (final SpecialEncounterTile et : this.tileEncounters) {
    		if (et != null && et.tileX == x && et.tileY == y) {
    			et.setNotEncounterable();
    			this.tileEncounters.remove(et);
    			this.tileEncountersRemoved.add(et);
    			this.map[x][y] = TileType.TERRAIN;
    			( (TiledMapTileLayer) this.tiledMap.getLayers().get("foreground")).getCell(getCorrectedCoordinateX(x), getCorrectedCoordinateY(y)).setTile(null);
    			for (final Position p : this.collisions) {
    				if (p.getX() == x && p.getY() == y) {
    					this.collisions.remove(p);
    					break;
    				}
    			}
    			return;
    		}
    	}
    }
	
	@Override
	public PokeMarket getPokeMarket() {
		return this.market;
	}


	@Override
	public Set<PokemonEncounterZone> getEncounterZones() {
		return Collections.unmodifiableSet(this.pokemonEncounterZones);
	}
	
	@Override
	public Optional<PokemonEncounterZone> getEncounterZone(final int x, final int y) {
		if (this.map[x][y] == TileType.POKEMON_ENCOUNTER) {
			for (final PokemonEncounterZone pez : this.pokemonEncounterZones) {
				if (pez.contains(x, y)) {
					return Optional.of(pez);
				}
			}
		}
		return Optional.empty();
	}
	
	
	@Override
	public int getCorrectedCoordinateX(final int cellX) {
		return cellX;
	}
	
	@Override
	public int getCorrectedCoordinateY(final int cellY) {
		return this.mapHeight - cellY - 1;
	}
	
	@Override
	public Tile.TileType[][] getMap() {
		return Arrays.copyOf(this.map, this.map.length);
	}
	
	@Override
	public Position getPokemonCenterSpawnPosition() {
		return this.pokeCenterSpawn;
	}
}
